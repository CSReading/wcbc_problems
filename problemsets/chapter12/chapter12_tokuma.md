# 12章

## 12.3


次の各問題がクラス`NPoly`に属する理由を説明せよ. クラス`NPoly`の定義を使うこと.インスタンスのそれぞれについて解を答えよ.
 (a) UHC問題の判定問題バージョン
 (b) IntergerDivision問題
 (c) AnonymousFriends問題
 (d) UHPOrigin問題


### (a)

ノードの数を$n$とする。

多項式時間で解ける以下のような非決定的プログラム$P$を構成する。

1. どのノードを利用するかを非決定的に定める
  - 選んだ始点ごとに、別のノードを利用するか、しないかで分岐する計算木を作成する。木の深さが順列を表す。各ノードでクローンを生成する。
  - どのケースに置いても、計算木の深さは最大でも$O(n)$である。
2. そのノードの順列がハミルトン閉路であるかを次のプロセスでチェックする
    - 選ばれたノードとその親ノードがつながる辺があるか: $O(n)$
      - 始点と終点の辺についても含む。
    - 辺の重複は計算木の構成方法により存在しない
3. ハミルトン閉路であれば、yes, そうでなければnoを返す。

したがって、木の深さは$O(n)$で、各ノードでの計算量は$O(n)$であるから、非決定性実行時間は$O(n^2)$であり、この問題は`NPoly`に含まれる。


### (b)

入力文字列の長さを$n$とする。
非決定性を活用していない非決定性プログラム$P$を以下のように構築する。

1. 入力文字列をスペースで分割する: $O(n)$
2. M/Nを計算する: $O(n^2)$
    - M, Nの長さはそれぞれ$\log M$, $\log N$であるが、これは$n$で抑えられる。
    - 商と余りかえってくる想定

3. 余りが0であれば,$M/N$ そうでなければnoを返す。

したがって非決定性実行時間は$O(n^2)$であり、この問題は`NPoly`に含まれる。


### (c)

**定義** グラフ同型

グラフ$G=(V_G, E_G)$と$H=(V_H, E_H)$に対して、全単射: $f: V_G \to V_H$があり、
$\{u, v\} \in E_G \leftrightarrow \{f(u), f(v) \} \in E_H$が成り立つ時、
$G$と$H$は同型である。

単純化のため、$L$, $A$のノード数をともに$k$とする。(ノード数が異なる場合はそもそもグラフ同型ではない。)

以下の様な非決定プログラム$P$を構築する。

1. 非決定的に$L$, $A$のノードを1つずつ取り出し、1対1写像の計算木(k個)を構築する。
   - 木の深さは$O(k)$である。
   - ex: $L$のノード$1$, $A$ノード$1^{\prime}$を対応させるようなイメージ

2. 対応させた1つのノードがそれぞれ適切なものとつながっているかを確認する: $O(k)$
    - 対応ノードごとに他のノードとのつながりはそれぞれたかだか$O(k)$個
3. 適切なものとつながっていればyes, そうでなければnoを返す。


このプログラムの非決定的計算量は木の深さ×計算木のノードでの計算量であるから$O(k^2)$である。

よって、この問題は`NPoly`クラスに属する。


### (d)
ノードの数を$n$とする。

多項式時間で解ける以下のような非決定的プログラム$P$を構成する。

1. どのノードを利用するかを非決定的に定める
  - 選んだ始点ごとに、別のノードを利用するか、しないかで分岐する計算木を作成する。木の深さが順列を表す。各ノードでクローンを生成する。
  - どのケースに置いても、計算木の深さは最大でも$O(n)$である。
2. そのノードの順列がハミルトン路であるかを次のプロセスでチェックする
    - 選ばれたノードとその親ノードがつながる辺があるか: $O(n)$
    - 辺の重複は計算木の構成方法により存在しない
3. ハミルトン路であれば、yes, そうでなければnoを返す。

したがって、木の深さは$O(n)$で、各ノードでの計算量は$O(n)$であるから、非決定性実行時間は$O(n^2)$であり、この問題は`NPoly`に含まれる。


## 12.8

```python
def verifyAdd(I, S, H):
    if len(S) > 2 * len(I) or len(H)>0:
        return 'unsure'

    (M1, M2) = [int(x) for x in I.split()]

    S = int(S)
    total = M1

    for i in range(M2):
        total += 1

    if total == S:
        return 'correct'
    else:
        return 'unsure'
```

`verifyAdd`関数が多項式時間検証器になっているかを示せ。


### 解答

`verifyAdd`は線形時間検証器である。

`verifyAdd`が検証器であることを示す。
`verifyAdd`は問題インスタンス$I$, 提案された解$S$, ヒント$H$を受けつけ、仮定よりすべての入力は正しい形式であるため、`correct`か`unsure`を返す。

また以下の条件を満たす。
- $I$が正インスタンスの場合
  - $S$が正しい解出ない場合は`unsure`
  - $S$が正しいが、$H$が正しいヒントでない場合は`unsure`
  - $S$が正しく、$H$が正しいヒントの場合は`correct`
- $I$が負インスタンスの場合は仮定より除かれている。
ので、検証器となっている。

したがって`verifyAdd`は検証器である。


次に`verifyAdd`が線形時間で解けることを示す。検討する必要がある部分は2箇所である。


1. splitパート
```python
(M1, M2) = [int(x) for x in I.split()]
```
p222-223にあるようにこの部分は$O(n)$の処理である。理由はsplitは$O(n)$の処理だが、分割した2つの文字列を整数変換するのは$O(len(s))$時間で実行出来るから。


2. 合計パート
```python
for i in range(M2):
        total += 1
```

この部分は`SUMK`問題と同じである。したがって$O(\log(M1))$で計算可能。いま$\log(M1)$は$n$で抑えられるので、この部分の計算量は$O(n)$とかける。


したがって、`verifyAdd`は線形時間で解くことが出来る。



## 12.13

`DIFFRENTPARTITIONS`


## (a) `DIFFERENTPARTITIONS`がクラス`PolyCheck`に含まれることを示せ


`DIFFERENTPATITIONS`が`PolyCheck`に含まれるためには、多項式時間検証器を作成すれば良い。

以下のものが検証器である。ヒントとして分割したリストの片方を要求する。

```python

def verify_diff_partition(I, S, H):

    # 過度に長い解とヒントを拒絶
    if len(S) > len(I) or len(H) > len(I):
        return 'unsure'

    if S == 'no':
        return 'unsure'

    # 数値をリストに
    w_list = [int(x) for x in I.split()]
    # 解答
    (w_res_1, w_res_2) = [int(x) for x in S.split()]

    # ヒントをリストに
    hint_list = [int(x) for x in H.split()]

    try:
        # ヒントが重みリストにあることを確認する
        # なければexceptに飛ぶ
        for x in hint_list:
            x in w_list


        # ヒント以外の重みリストを用意する
        res_list = []
        for x in w_list:
            if x in hint_list:
                continue
            else:
                res_list.append(x)


        # 以下の2つを確認する。
        # ヒントリストと、残りの重さリストの中に提案された解がが含まれているか
        # 重さの合計が一致しているか
        cond_1 = (w_res_1 in hint_list) & (w_res_2 in res_list)
        cond_2 = (w_res_1 in res_list) & (w_res_2 in hint_list)

        if (cond_1 | cond_2) & (sum(hint_list) == sum(res_list)):
            return 'correct'
        else:
            return 'unsure'

    except:
        return 'unsure'
```


次にこの検証器が多項式時間で実行出来ることを確認する。
計算コストが掛かるのは明らかにtryブロックの2箇所のforループである。

- ヒントの長さは入力文字列の長さ$n$で抑えられるから、forループは$O(n)$回回る。
- in演算子の実行時間も同様に$O(n)$である。
  - 検索対象のリストの長さは入力文字列の長さで抑えられるから。
- リストの末尾への追加はp218にあるように$O(1)$である。

したがって、それぞれのforループの計算量は$O(n^2)$である。

その他の部分はたかだか$O(n)$で計算出来るため、この検証器は多項式時間で実行可能である。


## (b) `DIFFERENTPARTITIONS`検証器が考慮しなければならないヒントの長さの上限


ヒントの長さの上限は問題インスタンスの長さである。

問題インスタンスIに含まれる数字の数をmとする。
最悪のケースでは$m-1$個, $1$個に分割されうる。したがってヒントの長さは問題インスタンスの長さで抑えられる。
